---
title: "Service Mesh의 이해: Istio를 활용한 MSA 네트워킹"
date: 2025-10-16
categories: [Architecture, MSA]
tags: [Service Mesh, Istio, Envoy, MSA, Kubernetes, Cloud Native, TIL]
excerpt: "마이크로서비스(MSA)가 복잡해지면서 발생하는 통신 문제를 해결하기 위한 Service Mesh의 개념을 학습합니다. 대표적인 구현체인 Istio의 아키텍처와 Sidecar Proxy 패턴을 통해, 애플리케이션 코드 수정 없이 어떻게 트래픽 제어, 보안, 모니터링을 구현하는지 알아봅니다."
author_profile: true
---

# Today I Learned: Service Mesh의 이해: Istio를 활용한 MSA 네트워킹

## 📚 오늘 학습한 내용

마이크로서비스 아키텍처(MSA)가 수십, 수백 개로 늘어나면 서비스 간의 네트워크 통신은 거미줄처럼 복잡해집니다. 서비스 검색(Service Discovery), 부하 분산(Load Balancing), 서킷 브레이커(Circuit Breaker), 타임아웃, 재시도 등 안정적인 통신을 위한 로직을 모든 서비스에 개별적으로 구현하는 것은 엄청난 부담입니다.

오늘은 이러한 **MSA의 네트워킹 문제를 애플리케이션 코드에서 분리**하여 인프라 레벨에서 해결하는 **서비스 메쉬(Service Mesh)**와 그 대표적인 구현체인 **Istio**에 대해 학습했습니다.

---

### 1. **서비스 메쉬(Service Mesh)란 무엇인가? 🕸️**

**서비스 메쉬**는 마이크로서비스 간의 통신을 처리하기 위해 구성된 **전용 인프라 계층(Dedicated Infrastructure Layer)**입니다. 애플리케이션 코드에 내장되던 네트워크 통신 관련 기능들을 애플리케이션 외부의 **프록시(Proxy)**로 빼내어 처리하는 방식입니다.

-   **핵심 아이디어**: 애플리케이션은 비즈니스 로직에만 집중하고, 복잡하고 반복적인 네트워크 통신 로직은 서비스 메쉬에 위임합니다.
-   **동작 방식: 사이드카 프록시 (Sidecar Proxy) 패턴**
    1.  쿠버네티스 환경에서, 각 애플리케이션 컨테이너(Pod)에 **Envoy**와 같은 경량 프록시 컨테이너를 함께 배포합니다. 이를 '사이드카'라고 부릅니다.
    2.  애플리케이션이 외부 서비스와 통신할 때, 모든 네트워크 트래픽은 이 사이드카 프록시를 통해 나가고 들어옵니다.
    3.  개발자는 애플리케이션 코드에는 네트워크 로직을 전혀 작성하지 않고, 대신 서비스 메쉬의 **제어부(Control Plane)**에 "A 서비스 호출이 3번 실패하면 연결을 차단해줘" 와 같은 정책을 설정합니다.
    4.  제어부는 이 정책을 모든 사이드카 프록시에 전달하고, 프록시들이 이 정책에 따라 트래픽을 자동으로 제어합니다.



---

### 2. **Istio: 가장 대표적인 서비스 메쉬 구현체**

**Istio**는 구글, IBM, Lyft가 함께 개발한 오픈소스 서비스 메쉬로, 현재 가장 널리 사용되는 구현체 중 하나입니다.

-   **Istio 아키텍처**:
    -   **데이터 플레인 (Data Plane)**: 실제 네트워크 트래픽이 흐르는 부분입니다. 각 서비스의 Pod에 배포된 **Envoy 프록시**들로 구성됩니다.
    -   **컨트롤 플레인 (Control Plane)**: 데이터 플레인의 모든 Envoy 프록시들을 중앙에서 관리하고 정책을 설정하는 두뇌 역할을 합니다. **Istiod**라는 단일 컴포넌트가 이 역할을 수행합니다.

-   **Istio가 제공하는 핵심 기능**:
    1.  **트래픽 관리 (Traffic Management)**:
        -   **동적 라우팅**: 요청 헤더나 쿠키 값에 따라 트래픽을 특정 버전의 서비스로 보내는 등 정교한 라우팅이 가능합니다. (e.g., A/B 테스팅, 카나리 배포)
        -   **타임아웃 및 재시도**: 특정 서비스에 대한 호출 시간을 제한하고, 실패 시 자동으로 재시도하는 정책을 코드 없이 설정할 수 있습니다.
        -   **서킷 브레이커**: 장애가 발생한 서비스로의 트래픽을 자동으로 차단하여 장애 전파를 막습니다.

    2.  **보안 (Security)**:
        -   **상호 TLS (mTLS)**: 서비스 간의 모든 통신을 자동으로 암호화하여 중간자 공격(Man-in-the-middle attack)을 방지합니다.
        -   **인가 정책**: "A 서비스는 B 서비스의 GET 메서드만 호출할 수 있다"와 같은 세밀한 접근 제어 정책을 설정할 수 있습니다.

    3.  **관찰 가능성 (Observability)**:
        -   **분산 추적 (Distributed Tracing)**: 모든 프록시가 요청 헤더에 추적 ID를 자동으로 주입해주어, MSA 환경에서 요청 하나가 어떤 서비스를 거쳐갔는지 전체 흐름을 추적할 수 있습니다. (e.g., Jaeger)
        -   **메트릭 수집**: 서비스 간의 요청 수, 에러율, 응답 시간 등 풍부한 **골든 시그널(Golden Signal)** 메트릭을 자동으로 수집하여 Prometheus로 전달합니다.

---

### 3. **Spring Cloud Gateway vs. Istio (API Gateway vs. Service Mesh)**

API Gateway와 서비스 메쉬는 종종 혼동되지만, 목적과 위치가 다릅니다.

| 구분 | **API Gateway (e.g., Spring Cloud Gateway)** | **Service Mesh (e.g., Istio)** |
| :--- | :--- | :--- |
| **주요 관심사** | **외부 트래픽** (North-South Traffic) | **내부 서비스 간 트래픽** (East-West Traffic) |
| **위치** | 클러스터의 **가장자리(Edge)**에 위치 | 클러스터 **내부**의 모든 서비스에 걸쳐 위치 |
| **주요 기능** | 외부 클라이언트 인증/인가, API 통합, 라우팅 | 서비스 간 mTLS, 서킷 브레이킹, 트래픽 제어, 추적 |
| **결론** | 서로를 대체하는 것이 아니라, **상호 보완적인 관계** |

---

## 💡 배운 점

1.  **비즈니스 로직과 인프라 로직의 완전한 분리**: 서비스 메쉬는 과거 라이브러리(e.g., Resilience4j, Ribbon) 형태로 애플리케이션 코드에 섞여 있던 네트워크 제어 로직을 인프라 계층으로 완전히 이전시키는 패러다임의 전환임을 깨달았습니다. 이를 통해 개발자는 순수한 비즈니스 로직에만 집중할 수 있습니다.
2.  **'제로 트러스트(Zero Trust)' 네트워크의 실현**: Istio의 mTLS 기능을 사용하면, 개발자가 보안에 대해 전혀 신경 쓰지 않아도 클러스터 내부의 모든 통신이 기본적으로 암호화됩니다. 이는 "내부 네트워크는 안전하다"는 낡은 가정을 버리고, 모든 통신을 신뢰하지 않는 '제로 트러스트' 보안 모델을 쉽게 구현할 수 있게 합니다.
3.  **운영의 복잡성은 증가한다**: 서비스 메쉬는 MSA의 복잡성을 해결해주지만, Istio 자체를 설치하고 운영, 관리하는 것은 또 다른 복잡성을 야기합니다. 소규모 MSA 환경에서는 배보다 배꼽이 더 클 수 있으며, 시스템의 규모와 복잡도를 고려하여 신중하게 도입해야 하는 고급 기술임을 알게 되었습니다.

---

## 🔗 참고 자료

-   [Istio 공식 문서](https://istio.io/latest/docs/)
-   [What is a Service Mesh? (NGINX)](https://www.nginx.com/resources/glossary/service-mesh/)
-   [Pattern: Service Mesh (Microservices.io)](https://microservices.io/patterns/service-mesh.html)