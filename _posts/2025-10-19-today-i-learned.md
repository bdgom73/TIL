---
title: "MySQL(InnoDB) 인덱스 동작 원리: 클러스터드와 논클러스터드"
date: 2025-10-19
categories: [Database, Performance]
tags: [MySQL, InnoDB, Index, Clustered Index, Non-Clustered Index, Performance Tuning, TIL]
excerpt: "데이터베이스 성능 튜닝의 핵심인 인덱스의 동작 원리를 학습합니다. 특히 MySQL InnoDB 엔진의 클러스터드 인덱스(Primary Key)와 논클러스터드(보조) 인덱스의 구조적 차이, 그리고 커버링 인덱스의 중요성을 알아봅니다."
author_profile: true
---

# Today I Learned: MySQL(InnoDB) 인덱스 동작 원리: 클러스터드와 논클러스터드

## 📚 오늘 학습한 내용

JPA와 QueryDSL을 사용하며 `select` 성능을 높이기 위해 인덱스를 생성하는 것은 익숙한 업무입니다. 하지만 단순히 `CREATE INDEX`를 추가하는 것을 넘어, **인덱스가 내부적으로 어떻게 동작하는지** 이해하는 것은 3~4년차 백엔드 개발자에게 필수적인 역량입니다.

오늘은 특히 제가 주로 사용하는 MySQL InnoDB 스토리지 엔진을 기준으로, 인덱스의 두 가지 핵심 유형인 **클러스터드 인덱스**와 **논클러스터드 인덱스**의 차이점을 깊이 있게 학습했습니다.

---

### 1. **핵심 자료구조: B-Tree (Balanced Tree)**

-   대부분의 RDBMS 인덱스는 B-Tree(정확히는 B+Tree) 자료구조를 사용합니다.
-   **왜 B-Tree인가?**: 데이터를 항상 정렬된 상태로 유지하며, 어떤 값을 찾든 탐색 경로의 깊이가 동일(Balanced)하여 데이터가 수백만, 수천만 건이 되어도 매우 빠르고 일정한 검색 속도를 보장합니다.
-   **비유**: 거대한 백과사전과 같습니다. 인덱스(B-Tree)는 사전의 '찾아보기' 역할을 하여, 전체를 다 뒤지지 않고도 원하는 정보(데이터 레코드)가 있는 페이지로 바로 이동시켜 줍니다.

---

### 2. **클러스터드 인덱스 (Clustered Index) 📖**

-   **개념**: **"데이터 자체가 인덱스"**인 방식입니다. 인덱스 키의 순서에 따라 데이터베이스의 **물리적인 데이터 레코드가 정렬**되어 저장됩니다.
-   **MySQL (InnoDB)에서의 구현**: **Primary Key (PK)**가 바로 클러스터드 인덱스입니다.
    -   테이블에 PK가 정의되면, InnoDB는 PK를 기준으로 모든 데이터를 물리적으로 정렬하여 저장합니다.
-   **비유**: **영어 사전 그 자체**와 같습니다. "Apple"이라는 단어(Key)를 찾으면, 그 자리에 "사과"라는 뜻(Data)이 함께 저장되어 있습니다. 사전 전체가 알파벳순으로 정렬되어 있습니다.
-   **특징**:
    -   테이블당 **오직 하나**만 존재할 수 있습니다. (데이터를 물리적으로 정렬하는 기준은 하나여야 하므로)
    -   PK를 기반으로 한 범위 검색(`BETWEEN`, `>`)이 매우 빠릅니다. (데이터가 이미 정렬되어 붙어있으므로)
    -   PK 기반 조회 시, 인덱스 탐색 한 번으로 모든 데이터(전체 Row)를 가져올 수 있어 속도가 가장 빠릅니다.



---

### 3. **논클러스터드 인덱스 (Non-Clustered / 보조 인덱스) 📑**

-   **개념**: 데이터 레코드의 **물리적인 순서와 상관없이** 별도의 공간에 생성되는 인덱스입니다.
-   **MySQL (InnoDB)에서의 구현**: PK를 제외한 모든 인덱스(Unique Index, 일반 Index 등)가 논클러스터드 인덱스입니다.
-   **비유**: 기술 서적 뒤편의 **"찾아보기" 페이지**와 같습니다. "JPA"라는 키워드를 찾으면, "p.50, p.120"과 같은 **페이지 번호(Pointer)**가 나옵니다.
-   **핵심 동작 (in InnoDB)**:
    -   논클러스터드 인덱스는 해당 컬럼의 값과, 데이터가 실제 저장된 위치를 가리키는 포인터를 저장합니다.
    -   **중요**: InnoDB에서 이 **포인터**는 물리적 주소값이 아니라, **해당 로우의 PK(클러스터드 인덱스 키) 값**입니다.

#### **'이중 조회 (Double Lookup)'가 발생하는 이유**
만약 `name` 컬럼에 논클러스터드 인덱스가 걸려있고, `email`을 조회한다면:
```sql
SELECT email FROM user WHERE name = 'John';
```
1.  **(1차 조회)** `name` 인덱스(논클러스터드)를 B-Tree 탐색하여 'John'을 찾습니다.
2.  `name` 인덱스에는 'John'의 `email`이 없고, 대신 'John'의 **PK 값**(e.g., `id = 150`)이 저장되어 있습니다.
3.  **(2차 조회)** 획득한 PK 값 `150`을 가지고, **클러스터드 인덱스(PK 인덱스)**를 다시 B-Tree 탐색합니다.
4.  PK 인덱스에는 `id = 150`인 로우의 모든 데이터(`id`, `name`, `email`...)가 저장되어 있으므로, 여기서 `email` 값을 찾아 반환합니다.

---

### 4. **성능 최적화: 커버링 인덱스 (Covering Index)**

위의 '이중 조회'는 성능 저하의 주범입니다. **커버링 인덱스**는 이 이중 조회를 피하는 매우 중요한 최적화 기법입니다.

-   **개념**: 쿼리에 필요한 **모든 데이터가 논클러스터드 인덱스에 포함**되어 있어, 클러스터드 인덱스(실제 데이터)를 추가로 조회할 필요가 없는 인덱스를 말합니다.
-   **예시**: `(name, email)` 두 컬럼으로 복합 인덱스를 생성했다고 가정해봅시다.
    ```sql
    CREATE INDEX idx_name_email ON user (name, email);
    ```
    이때 다음 쿼리를 실행하면:
    ```sql
    SELECT name, email FROM user WHERE name = 'John';
    ```
    1.  `(name, email)` 인덱스를 탐색하여 'John'을 찾습니다.
    2.  쿼리가 요구하는 `name`과 `email` 컬럼이 **모두 이 인덱스 안에 존재**합니다.
    3.  DB는 클러스터드 인덱스를 2차 조회할 필요 없이, 인덱스에서 바로 결과를 반환하고 쿼리를 종료합니다.

---

## 💡 배운 점

1.  **InnoDB에서 PK 설계는 운명이다**: InnoDB 테이블은 그 자체가 거대한 클러스터드 인덱스 덩어리라는 것을 알게 되었습니다. PK를 어떻게 설계하느냐(e.g., `Auto-increment` 정수형 vs. `UUID` 문자열)가 데이터의 물리적 저장 구조와 보조 인덱스의 성능까지 모두 결정짓는 핵심적인 설계임을 깨달았습니다.
2.  **`SELECT *`는 죄악이다**: `SELECT *`를 사용하면, 거의 모든 경우에 커버링 인덱스를 활용할 수 없게 되어 불필요한 '이중 조회'를 유발합니다. JPA나 QueryDSL을 사용할 때도 엔티티 전체를 조회하기보다, DTO 프로젝션을 통해 꼭 필요한 컬럼만 `SELECT`하는 습관이 왜 중요한지 기술적으로 이해했습니다.
3.  **인덱스 설계는 'WHERE'뿐만 아니라 'SELECT'도 고려해야 한다**: 지금까지는 `WHERE` 절에 들어가는 조건 컬럼만 인덱스로 만들면 된다고 단순하게 생각했습니다. 하지만 '커버링 인덱스'의 개념을 배우고 나니, `SELECT` 절에 포함되는 컬럼까지 고려하여 복합 인덱스를 설계하는 것이 성능 최적화의 핵심임을 알게 되었습니다.

---

## 🔗 참고 자료

-   [MySQL Docs - Clustered and Secondary Indexes](https://dev.mysql.com/doc/refman/8.0/en/innodb-index-types.html)
-   [High Performance MySQL (Book)](https://www.oreilly.com/library/view/high-performance-mysql/9781449314286/)
-   [Real MySQL 8.0 (Book)](https://www.yes24.com/Product/Goods/103217451)