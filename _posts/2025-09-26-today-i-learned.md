---
title: "CQRS 패턴: 데이터 처리의 명령과 조회를 분리하라"
date: 2025-09-26
categories: [Architecture, Design Pattern]
tags: [CQRS, MSA, DDD, System Design, Event Sourcing, TIL]
excerpt: "복잡한 도메인에서 시스템의 성능과 확장성을 극대화하는 CQRS(Command Query Responsibility Segregation) 패턴의 핵심 개념을 학습합니다. 명령과 조회 모델을 분리했을 때의 장점과 고려사항, 그리고 언제 이 패턴을 사용해야 하는지 알아봅니다."
author_profile: true
---

# Today I Learned: CQRS 패턴: 데이터 처리의 명령과 조회를 분리하라

## 📚 오늘 학습한 내용

하나의 데이터 모델로 데이터의 생성/수정/삭제(CUD)와 조회(R)를 모두 처리하는 것은 간단한 CRUD 애플리케이션에서는 효과적입니다. 하지만 비즈니스 로직이 복잡해지고, 읽기(Read)와 쓰기(Write)의 요구사항이 달라지기 시작하면 이 단순한 모델은 한계에 부딪힙니다. 오늘은 이러한 문제를 해결하기 위한 강력한 아키텍처 패턴인 **CQRS(Command Query Responsibility Segregation)**에 대해 학습했습니다.

---

### 1. **CQRS 패턴이란 무엇인가?**

CQRS는 말 그대로 **명령(Command)과 조회(Query)의 책임을 분리**하는 패턴입니다. 시스템의 데이터 모델을 두 가지로 나누는 것이 핵심입니다.

-   **Command Model**: 데이터의 상태를 변경하는 책임. 즉, 생성(Create), 수정(Update), 삭제(Delete) 작업을 수행합니다. **"데이터를 어떻게 변경할 것인가"**에 집중합니다.
-   **Query Model**: 데이터를 조회하는 책임. 즉, 읽기(Read) 작업을 수행합니다. **"데이터를 어떻게 보여줄 것인가"**에 집중합니다.

창고 관리 시스템을 예로 들어봅시다.
-   **명령(Command)**: 입고/출고 부서. 재고를 등록하고, 출고시키며, 재고량을 변경하는 엄격한 규칙과 절차를 따릅니다.
-   **조회(Query)**: 재고 현황 보고 부서. 현재 재고 목록, 특정 상품의 위치 등 다양한 조건으로 최적화된 보고서를 빠르고 효율적으로 생성하는 데 집중합니다.

이 두 부서가 같은 장부와 시스템을 쓴다면 서로의 작업에 방해가 될 수 있습니다. CQRS는 이 두 부서에 각각 최적화된 별도의 시스템을 제공하는 것과 같습니다.


---

### 2. **CQRS의 구성 요소와 동작 방식**

CQRS 아키텍처는 크게 **명령(Write) 측**과 **조회(Read) 측**, 그리고 이 둘을 동기화하는 메커니즘으로 구성됩니다.

#### **🔵 Command Side (쓰기 모델)**

-   **역할**: 데이터의 일관성과 무결성을 책임집니다. 모든 비즈니스 로직과 유효성 검사는 이쪽에서 처리됩니다.
-   **데이터 모델**: 정규화된(Normalized) 데이터 모델을 사용하여 데이터 중복을 최소화하고 일관성을 유지하는 데 유리합니다. (e.g., RDBMS)
-   **흐름**:
    1.  사용자 요청이 **Command** 객체로 시스템에 전달됩니다.
    2.  **Command Handler**가 이 Command를 받아 비즈니스 로직을 수행합니다.
    3.  데이터베이스(Write DB)의 상태를 변경합니다.
    4.  상태 변경이 완료되면, 변경되었다는 **이벤트(Event)**를 발행(Publish)합니다.

#### **🟢 Query Side (읽기 모델)**

-   **역할**: 데이터를 빠르고 효율적으로 조회하는 것을 최우선 목표로 합니다.
-   **데이터 모델**: 특정 화면이나 API 응답에 최적화된 비정규화된(Denormalized) 데이터 모델을 사용합니다. Join이 미리 계산된 View와 같은 형태를 가집니다. (e.g., NoSQL, Elasticsearch, 또는 RDBMS의 View Table)
-   **흐름**:
    1.  **Event Handler**(또는 동기화 프로세스)가 Command 측에서 발행된 이벤트를 구독(Subscribe)합니다.
    2.  이벤트를 기반으로 조회용 데이터베이스(Read DB)를 최신 상태로 업데이트합니다.
    3.  사용자는 **Query**를 통해 이 최적화된 Read DB에서 데이터를 매우 빠르게 읽어갑니다.

이러한 이벤트 기반 동기화 방식 때문에 Command 측의 변경 사항이 Query 측에 반영되기까지 약간의 지연이 발생할 수 있으며, 이를 **최종 일관성(Eventual Consistency)**이라고 합니다.

---

### 3. **CQRS의 장점과 단점 (그리고 언제 사용해야 하는가?)**

CQRS는 강력한 만큼 모든 상황에 적합한 만능 해결책은 아닙니다.

#### **장점 👍**

1.  **성능 최적화**: 읽기 작업과 쓰기 작업을 각각의 요구사항에 맞게 독립적으로 최적화할 수 있습니다. 쓰기 모델은 정규화를 통해 일관성을, 읽기 모델은 비정규화를 통해 조회 속도를 극대화할 수 있습니다.
2.  **독립적인 확장성**: 읽기 트래픽이 많으면 읽기 DB의 복제본(Replica)만 늘리고, 쓰기 트래픽이 많으면 쓰기 DB의 성능을 높이는 등 독립적인 확장이 가능합니다.
3.  **유연성과 보안**: Command 모델과 Query 모델에 각기 다른 기술 스택을 적용할 수 있습니다. (e.g., 쓰기는 RDBMS, 읽기는 Elasticsearch). 또한, 조회 전용 모델을 외부에 노출하여 보안을 강화할 수 있습니다.

#### **단점 👎**

1.  **복잡성 증가**: 두 개의 데이터 모델과 이 둘을 동기화하는 메커니즘을 추가로 구현하고 관리해야 하므로 전체 시스템의 복잡도가 크게 증가합니다.
2.  **최종 일관성**: 데이터 동기화 과정에서 발생하는 지연으로 인해 사용자가 방금 변경한 내용이 즉시 조회되지 않을 수 있습니다. 실시간 일관성이 반드시 필요한 서비스에는 부적합할 수 있습니다.
3.  **개발 비용 증가**: 더 많은 코드를 작성해야 하며, CQRS와 이벤트 소싱 등 관련 패턴에 대한 학습 곡선이 존재합니다.

#### **언제 사용해야 할까?**

-   읽기와 쓰기 워크로드가 매우 다르며, 각각 높은 성능 요구사항을 가질 때.
-   복잡한 비즈니스 규칙이 적용되는 협업 도메인 (e.g., 온라인 쇼핑몰의 주문/결제 시스템).
-   단일 모델로는 모든 데이터 표현 요구사항을 만족시키기 어려울 때.

단순한 CRUD 기능만 가진 대부분의 애플리케이션에는 CQRS가 과도한 설계(Over-engineering)일 수 있습니다.

---

## 💡 배운 점

1.  **CQRS는 아키텍처가 아닌 패턴이다**: CQRS는 시스템 전체를 구성하는 최상위 아키텍처라기보다는, DDD(도메인 주도 설계)의 Bounded Context와 같이 특정 도메인 내에서 문제 해결을 위해 적용할 수 있는 강력한 '패턴'임을 이해했습니다.
2.  **'분리'의 강력함**: 책임과 역할을 명확히 분리하는 것이 소프트웨어 공학의 핵심 원칙임을 다시 한번 깨달았습니다. CQRS는 이 원칙을 데이터 모델 수준까지 적용하여 성능과 확장성이라는 두 마리 토끼를 잡는 전략입니다.
3.  **기술 선택의 이유**: 왜 어떤 시스템은 Elasticsearch를 조회용으로만 사용하고, 데이터 변경은 RDBMS를 통해 처리하는지에 대한 기술적인 근거를 명확히 이해하게 되었습니다. 각 기술의 장점을 조합하여 시스템 전체의 효율을 극대화하는 것이 CQRS의 진정한 힘입니다.

---

## 🔗 참고 자료

-   [Martin Fowler - CQRS](https://martinfowler.com/bliki/CQRS.html)
-   [Microsoft Docs - CQRS Pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs)
-   [CQRS.nu - Greg Young](https://cqrs.nu/)