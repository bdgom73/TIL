---
title: "데이터베이스 동시성 제어: 트랜잭션 격리 수준과 잠금 전략"
date: 2025-10-02
categories: [Database, CS]
tags: [Transaction, Isolation Level, Lock, Concurrency, Pessimistic Lock, Optimistic Lock, TIL]
excerpt: "다중 트랜잭션 환경에서 데이터의 일관성을 지키기 위한 트랜잭션 격리 수준(Isolation Level)과 각 수준에서 발생하는 문제점들을 학습합니다. 또한, 동시성 제어를 위한 비관적/낙관적 잠금(Pessimistic/Optimistic Lock) 전략의 차이점과 사용 사례를 알아봅니다."
author_profile: true
---

# Today I Learned: 데이터베이스 동시성 제어: 트랜잭션 격리 수준과 잠금 전략

## 📚 오늘 학습한 내용

여러 사용자가 동시에 접근하는 데이터베이스 환경에서 **데이터의 일관성과 무결성**을 지키는 것은 매우 중요합니다. 하나의 트랜잭션이 데이터를 수정하는 동안 다른 트랜잭션이 해당 데이터를 어떻게 다룰지를 정의하는 것이 바로 **트랜잭션 격리 수준(Isolation Level)**입니다. 오늘은 이 격리 수준의 종류와 각 수준에서 발생하는 문제점, 그리고 동시성 제어를 위한 두 가지 주요 **잠금(Lock) 전략**에 대해 학습했습니다.

---

### 1. **동시성 문제: 왜 격리가 필요한가?**

격리 수준을 제대로 설정하지 않으면, 여러 트랜잭션이 동시에 실행될 때 다음과 같은 문제들이 발생할 수 있습니다.

-   **Dirty Read (더티 리드)**
    -   **현상**: 한 트랜잭션이 **커밋(commit)되지 않은** 데이터를 다른 트랜잭션이 읽는 문제입니다.
    -   **문제점**: 만약 첫 번째 트랜잭션이 롤백(rollback)된다면, 두 번째 트랜잭션은 존재하지 않는 '더러운' 데이터를 기반으로 로직을 수행하게 되어 데이터 불일치가 발생합니다.

-   **Non-Repeatable Read (반복 불가능 읽기)**
    -   **현상**: 한 트랜잭션 내에서 **같은 데이터를 두 번 읽었는데, 그 결과가 다른** 문제입니다.
    -   **문제점**: 첫 번째 읽기와 두 번째 읽기 사이에 다른 트랜잭션이 데이터를 수정하고 커밋해버렸기 때문입니다. 이로 인해 트랜잭션의 일관된 수행이 어려워집니다.

-   **Phantom Read (팬텀 리드)**
    -   **현상**: 한 트랜잭션 내에서 **같은 쿼리를 두 번 실행했는데, 첫 번째 쿼리에서는 없었던 '유령' 같은 레코드가 두 번째 쿼리에서 나타나는** 문제입니다.
    -   **문제점**: Non-Repeatable Read가 특정 레코드의 '수정'에 의한 것이라면, Phantom Read는 다른 트랜잭션의 '추가(insert)'에 의해 발생합니다. 범위 기반의 쿼리에서 데이터 정합성이 깨질 수 있습니다.



---

### 2. **트랜잭션 격리 수준 (Transaction Isolation Levels)**

SQL 표준은 이러한 문제들을 해결하기 위해 4가지 격리 수준을 정의합니다. 격리 수준이 높아질수록 일관성은 강화되지만, 동시성은 저하(성능 저하)되는 트레이드오프 관계가 있습니다.

| 격리 수준 | Dirty Read | Non-Repeatable Read | Phantom Read |
| :--- | :---: | :---: | :---: |
| **READ UNCOMMITTED** | 발생 | 발생 | 발생 |
| **READ COMMITTED** | **방지** | 발생 | 발생 |
| **REPEATABLE READ** | **방지** | **방지** | 발생 |
| **SERIALIZABLE** | **방지** | **방지** | **방지** |

-   **Level 0: `READ UNCOMMITTED`**
    -   가장 낮은 격리 수준. 어떤 트랜잭션의 변경 내용이 커밋이나 롤백 여부에 상관없이 다른 트랜잭션에 보입니다. 거의 사용되지 않습니다.
-   **Level 1: `READ COMMITTED`**
    -   **커밋된 데이터만** 읽을 수 있도록 하여 Dirty Read를 방지합니다. Oracle, PostgreSQL 등의 기본 격리 수준입니다.
-   **Level 2: `REPEATABLE READ`**
    -   트랜잭션이 시작될 때의 데이터 버전을 스냅샷으로 만들어, 트랜잭션이 끝날 때까지 **일관된 데이터**를 읽도록 보장합니다. Non-Repeatable Read를 방지합니다. MySQL(InnoDB)의 기본 격리 수준입니다.
-   **Level 3: `SERIALIZABLE`**
    -   가장 엄격한 격리 수준. 트랜잭션을 순차적으로 실행하는 것과 같이 동작하여 모든 동시성 문제를 방지합니다. 하지만 잠금이 많이 발생하여 동시 처리 성능이 크게 떨어집니다.

---

### 3. **잠금(Lock) 전략: 비관적 잠금 vs. 낙관적 잠금**

격리 수준 외에도, 개발자는 애플리케이션 레벨에서 동시성을 제어하기 위해 잠금 전략을 선택할 수 있습니다.

#### ** pessimistic_lock: 비관적 잠금 (Pessimistic Lock)**

-   **철학**: "충돌은 분명히 일어날 것이니, 미리 막아버리자."
-   **동작 방식**: 데이터에 접근할 때부터 **배타적인 잠금(Exclusive Lock)**을 겁니다. 트랜잭션이 데이터를 읽는 순간부터 `SELECT ... FOR UPDATE` 구문을 사용하여 다른 트랜잭션이 해당 데이터에 접근하지 못하도록 막습니다.
-   **장점**: 데이터의 정합성을 확실하게 보장합니다.
-   **단점**: 잠금으로 인한 성능 저하와 데드락(Deadlock) 발생 가능성이 있습니다.
-   **사용 사례**: 충돌이 빈번하게 발생하는 시스템 (e.g., 재고 차감, 계좌 이체, 선착순 티켓 예매).
-   **JPA**: `@Lock(LockModeType.PESSIMISTIC_WRITE)` 애노테이션으로 구현할 수 있습니다.

#### ** optimistic_lock: 낙관적 잠금 (Optimistic Lock)**

-   **철학**: "충돌은 거의 일어나지 않을 것이니, 일단 진행하고 마지막에만 확인하자."
-   **동작 방식**: 데이터를 읽을 때는 잠금을 걸지 않습니다. 대신, 데이터를 수정하고 커밋하는 시점에 **데이터가 변경되었는지 확인**합니다. 주로 **버전(Version)** 관리 컬럼을 사용합니다.
    1.  데이터를 읽을 때 버전 정보도 함께 읽습니다.
    2.  데이터를 수정하고 커밋할 때, 현재 데이터베이스의 버전과 내가 읽었던 버전이 동일한지 확인합니다.
    3.  버전이 다르다면(다른 트랜잭션이 먼저 수정한 경우), 현재 트랜잭션을 롤백하고 예외를 발생시킵니다.
-   **장점**: 잠금을 사용하지 않으므로 비관적 잠금보다 성능이 좋습니다.
-   **단점**: 충돌이 발생하면 개발자가 직접 재시도 로직 등을 처리해야 합니다.
-   **사용 사례**: 읽기 작업이 대부분이고 쓰기 충돌이 거의 없는 시스템 (e.g., 게시글 수정, 사용자 정보 변경).
-   **JPA**: `@Version` 애노테이션으로 간단하게 구현할 수 있습니다.

---

## 💡 배운 점

1.  **격리 수준은 '정답'이 아닌 '선택'이다**: 모든 시스템에 `SERIALIZABLE`을 적용하는 것이 능사가 아닙니다. 서비스의 특성과 데이터의 중요도를 고려하여, 어느 정도의 동시성 문제를 감수하고 성능을 얻을 것인지(낮은 격리 수준), 아니면 성능을 희생하더라도 데이터 정합성을 지킬 것인지(높은 격리 수준)를 선택해야 하는 트레이드오프 관계임을 이해했습니다.
2.  **MySQL의 `REPEATABLE READ`는 팬텀 리드를 대부분 막아준다**: MySQL의 InnoDB 엔진은 `REPEATABLE READ` 수준에서 갭 락(Gap Lock)이라는 특별한 잠금 방식을 사용하여 팬텀 리드 문제까지 대부분 방지해준다는 사실을 알게 되었습니다. 이는 표준 격리 수준 이상의 기능을 제공하는 데이터베이스별 특성을 이해하는 것이 중요함을 보여줍니다.
3.  **잠금 전략은 애플리케이션의 성격을 반영한다**: 비관적 잠금과 낙관적 잠금 중 어느 것이 더 좋다고 말할 수 없습니다. 충돌이 잦은 재고 시스템이라면 비관적 잠금이, 충돌이 거의 없는 정보성 게시판이라면 낙관적 잠금이 더 적합합니다. 애플리케이션의 데이터 경합(Contention) 수준을 파악하고 그에 맞는 전략을 선택하는 것이 핵심임을 깨달았습니다.

---

## 🔗 참고 자료

-   [MySQL Docs - Transaction Isolation Levels](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html)
-   [JPA Locking (Baeldung)](https://www.baeldung.com/jpa-pessimistic-locking)
-   [Optimistic vs. Pessimistic Locking (Vlad Mihalcea)](https://vladmihalcea.com/a-beginners-guide-to-database-locking-and-the-lost-update-phenomena/)